---
layout: post
title: "Philosophers init"
description: "42서울 Philosophers과제 방향성 정리."
date: 2022-02-15
tags: [42Seoul, Philosophers, 철학자]
comments: true
share: true
---

# Philosophers과제 방향성
## 0. 조건, 함수 정리.
<details>
<summary> 과제 정리 </summary>
<div markdown="1">       
필수 파트에 하나, 보너스 파트에 하나의 프로그램을 만드세요. 두 프로그램은 모두 같은 기본 룰을 따릅니다:
- 이 프로젝트는 Norm을 준수한 C 언어를 사용하여 코딩되어야 하며, 누수, 비정상적인 종료 (Crash), 정의되지 않은 동작, Norm 에러는 0점을 받게 됩니다.
- 한 명 이상의 철학자가 둥근 테이블에 앉아 다음과 같은 세 행동 중 하나를 취합니다 : 먹기, 생각하기, 잠자기
- 철학자가 밥을 먹는 도중에는, 생각하거나 잠을 자지 않습니다. 마찬가지로 잠자는 도중에는 밥을 먹거나 생각할 수 없으며, 생각하는 도중에는 밥을 먹거나 잠들 수 없습니다.
- 철학자들은 둥근 테이블에 앉아있으며, 가운데에는 아주 큰 스파게티 그릇이 놓여 있습니다.
탁자 위에는 몇 개의 포크가 올려져 있습니다.
- 스파게티는 포크 하나만으론 집거나 먹기가 어렵기 때문에, 철학자들은 반드시 양 손에 포크를 쥐고 (2개의 포크를 사용하여) 먹어야 합니다.
- 철학자는 절대로 굶고 있으면 안 됩니다.
- 모든 철학자는 먹어야 합니다.
- 철학자들은 서로와 대화할 수 없습니다.
- 각 철학자는 다른 철학자가 언제 죽는지 알아챌 수 없습니다.
- 철학자가 밥을 다 먹었으면, 포크를 내려놓고 잠자기 시작합니다.
- 철학자가 잠을 다 잤으면, 생각하기 시작합니다.
- 철학자가 한 명이라도 사망하면 시뮬레이션이 종료됩니다.

- 각 프로그램은 같은 옵션을 가져야 합니다 : 철학자의 수, 철학자의 수명, 밥을 먹는데 걸리는 시간, 잠자는 시간, [각 철학자가 최소한 밥을 먹어야 하는 횟수] (number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat])
  - 철학자의 수 (number_of_philosophers): 테이블에 앉아 있는 철학자의 수와 포크의 수
  - 철학자의 수명 (time_to_die): 밀리초 단위로, 철학자가 마지막으로 밥을 먹은 지 'time_to_die' 시간만큼이 지나거나, 프로그램 시작 후 'time_to_die' 시간만큼이 지나면 해당 철학자는 사망합니다.
  - 밥을 먹는데 걸리는 시간 (time_to_eat) : 밀리초 단위로, 철학자가 밥을 먹는 데 걸리는 시간입니다. 해당 시간동안, 철학자는 두 개의 포크를 소유하고 있어야 합니다.
  - 잠자는 시간 (time_to_sleep) : 밀리초 단위로, 잠을 자는 데 소모되는 시간입니다.
  - 각 철학자가 최소한 밥을 먹어야 하는 횟수 (number_of_times_each_philosopher_must_eat) : 해당 인자값은 선택사항입니다. 모든 철학자가 'number_of_times_each_philosopher_must_eat' 횟수만큼 밥을 먹었다면, 시뮬레이션이 종료됩니다. 해당 값이 명시되어 있지 않다면, 철학자가 한 명이라도 사망할 때까지 시뮬레이션은 계속됩니다.
  - 각 철학자에게는 1부터 'number_of_philosophers' 만큼의 고유 번호가 부여됩니다.
  - 철학자 1번은 철학자 'number_of_philosophers'번 옆에 앉습니다. 그 외에, N번 철학자는 N-1번 철학자와 N+1번 철학자 사이에 앉습니다.
- 철학자의 상태는 다음과 같은 형식으로 출력되어야 합니다. (X는 철학자의 고유 번호로 대체되어야 하며, timestamp_in_ms는 현재 타임스탬프가 밀리초 단위로 표시되어야 합니다.)

`timestamp_in_ms X has taken a fork`
`timestamp_in_ms X is eating`
`timestamp_in_ms X is sleeping`
`timestamp_in_ms X is thinking`
`timestamp_in_ms X died`

- 철학자의 상태는 다른 철학자들의 상태와 뒤엉키거나 섞인 상태로 출력되면 안 됩니다.
- 철학자의 사망 시점과 이를 출력하기 까지의 틈이 10ms 이상이 되면 안 됩니다.

다시 말하지만, 철학자들이 최대한 죽지 않도록 설계해야 합니다!

출처 : 42seoul-translation.

</div>
</details>

<details>
<summary> 사용 가능 함수들. </summary>
<div markdown="1">  
`memset`, `printf`, `malloc`, `free`, `write`, `usleep`, `gettimeofday`, `pthread_create`, `pthread_detach`, `pthread_join`, `pthread_mutex_init`, `pthread_mutex_destroy`, `pthread_mutex_lock`, `pthread_mutex_unlock`



추가 : libft 사용 불가.
</div>
</details>

## 1. 뭐하는 과제일까?
철학자 각각은 스레드이고, 철학자는 특정(위치)의 포크(자원) 2개를 점유해야 식사가 가능하다. 만약 식사를 하지 못하고 일정시간이 지나면 죽계되며 프로세스가 종료된다.

교착상태를 회피하게 하는 방법을 생각해보는 과제
## 2. 과제 특징
- 멀티 스래드 환경에서 교착상태를 예방|회피|처리하는 OS의 특정 기능을 구현하는 과제.
- 교착상태가 필요조건인 상호배제, 비선점, 점유/대기, 원형대기가 모두 충족되된다.
- 자원이 절대적으로 적고, 일정시간 이상 기아상태가 되면 안되는 제약조건도 있다.
- 이러한 상태에서 철학자를 죽이지 않고 계속 살려야한다...

무조건 철학자게 죽게되는 되는 input기준은 무엇일까?

## 2. 내가 생각하는 과제의 특이사항
아래의 내용들은 과제를 구현하기 전에 어떻게 구현하는게 빡세고 이상적일지 생각을 해보는 부분이다.
- 내(OS)가 제한할수 있는건 오직 포크뿐이다.
  - 철학자는 집을수 있는 포크가 포착되면 무조건 선점하고 놓지 않는다.
    -> 오른쪽부터 확인할지 왼쪽부터 확인할지는 시간의 LSB를 통해서 랜덤으로?
  - 철학자가 집은 포크를 뺏을수 없다.
  - 교착상태 회복을 위해 철학자를 죽였다가 되살릴수 없다.
- usleep은 최대한 지양한다. 하더라도 usleep을 넣는게 어떤영향을 미치는지 파악한다.
- 터미널에 출력하는게 시스템 성능/자원에 영향을 미친다면, 다른방식의 출력(log파일에 입력)은 어떨지 생각해본다.
- 철학자가 죽은 시간은 죽은걸 확인한 시간이 아니라, 밥 다먹은 시간 + 수명 값이다.
- 포크를 제한할때 그 정도를 잘 정해야한다.
  -> 자원을 제한하면 철학자가 더 쉽게 굶어죽기 때문에

## 3. 통상적인 교착상태 처리방식과 적용고찰
교착상태는 아사형상과 달리 정책의 잘못/오류가 없어도 자연적으로 발생하는 상황이다. 또한 완벽하게 해결할수 없고, 완벽하게 막을수 없다.
### 3.1 교착 상태 예방
교착상태 필요조건인 상호배제, 비선점, 점유/대기, 원형대기 중 하나를 무력화하는 방식.
- ~~상호 배제 예방~~ -> 자원이 정해져 있으므로 불가.
- ~~비선점 예방~~ -> 철학자의 포크는 뺏을수 없으므로 불가.
- 점유/대기 예방 -> 전부할당하거나 전혀하지 않는 방식사용한다. 가능은 할거같지만 자원의 활용성이 떨어지므로 철학자가 더 쉽게 굶어죽을것 같다.
- 원형 대기 예방 -> 원형대기 상태가 될 수 없게한다. 포크에 번호를 매기고(0부터 1씩 증가), 작은 숫자의 포크를 잡고 있을때만 그 다음포크를 주는 방식을 취한다. 자원 할당의 방향이 강제되어서 유연성이 떨어진다(마우스, 키보드자원 요청시 마우스->키보드 순서로만 작동되는 상황...).

점유/대기 예방 방식과 원형대기 예방 방식이 가장 유용해 보인다.

일반적인 OS에서 교착상태 예방기법은 사용하지 않는다. 운영 방식을 제한을 하기 때문이다. -> 비정상적인 동작방식.

### 3.2 교착 상태 회피
자원 할당량을 조절하여 교착상태를 해결하는 방식. 예방은 교착 구조가 생기지 않게 자원 분배(동작)방식을 변경하는 것이고, 회피는 자원의 양을 조절하는 것이다.
- 3.2.1 은행원 알고리즘

하지만.. 멘데토리 부분은 할당되는 자원 모자라서 아니라, 특정 자원(왼쪽/오른쪽 포크)만을 요구하는 프로세스가 교착상태가 발생시킨다. 자원의 총량을 조절해서 해결될 문제가 아니다. 따라서 일반적인 은행원 알고리즘을 적용하기 힘들것 같다. 보너스 부분에 적용 해야할듯 보임.

### 3.3 교착상태 검출 및 회복
교착상태는 막을수 없고, 회피할순 있지만 그 과정에서도 자원을 낭비하게 된다. 따라서 차라리 교착상태에 걸려버리고 후속처리를 하는 방식이다. 교착상태가 확인(검출)되면 교착상태인 프로세스를 강제 종료(회복)한다. 가장 현실적이고 보편적인 방법이지만. 해당과제에 적합한 방식이 아니다.
