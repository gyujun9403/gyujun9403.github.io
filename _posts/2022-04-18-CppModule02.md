---
layout: post
title: "CppModule 02"
description: "42서울 CPP02 과제"
date: 2022-04-18
tags: [42Seoul, cpp, canonical, 연산자, 오버로딩]
comments: true
share: true
---

## ex00 My First Canonical Class
의도가 뭔데??????
아래에서 재대로 만들거고, 여기는 그냥 진짜 canonical class form으로 클래스를 생성해보는 부분.
일단 별 기능 없더라도 여기서는 만들라고 하는 폼 대로 클래스를 작성한다.

### Canonical이란?
Canonical :정규적인. -> Canonical form class :정규적인 형태의 클래스...

Orthodox canonical class form = OCCF

사실 OCCF에 대해 오피셜한 레퍼런스는 없어보인다... 하지만 관례적으로 다음과 내용이 가장 중요해 본인다.

OCCF를 준수하는 클래스는 c++98, c++03컴파일러가 자동적으로 생성하는 아래와 같은 항목들에 대해서 선언 및 정의한다(=컴파일러가 자동 생성되는 항목들에 대해서 핸들링 해놓는다).
1. 기본생성자 -> Class::Class()
2. 복사 생성자(대입 생성자?) -> Class::Class(const Class&)
3. 대입 연산자 -> Class& operator=(const Class&)
4. 소멸자 -> Class::~Class()

ref : [advanced c++ programming styles and idioms, James O. Coplien 발췌 글](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=oidoman&logNo=90045961704), [Orthodox canonical class form](https://www.francescmm.com/orthodox-canonical-class-form/)

## ex01 Towards a more useful fixed point class
ex00에서 만든 클래스에 본격적으로 쓸만한 기능들을 추가하는 단계

### 고정소수점

과제에서 요구하는 고정 소수점의 형태는 32bit중 24bit는 정수데이터, 8bit는 소수데이터이다.
따라서 입력시에는 

- float데이터를 8bit만큼 shift(= *256)하여 **소수부분 8자리를 보존**한다. 

이때 정수부분 msb 8자리에 데이터가 있을수 있지만 어쩔수 없으므로 무시한다. 또한 left shift연산 및 양수 곱 연산 할 때 부호비트는 영향을 받지 않으므로 신경쓰지 않아도 된다.

- 반대로 출력시에는 int로 저장되어있던 데이터를 다시 right shift연산하여 **복구**하여 가지고 온다. 

이때 들어와서 변환한 데이터가 int인지 float인지는 알 수 없으므로 int형을 입력받을때도 left shift연산을 하고, 출력할때 일괄적으로 right shift연산을 하여 보존하기 위해 왼쪽으로 이동시켰던 소수점 8bit를 다시 오른쪽으로 8bit옮긴다.

### 연산자 오버로딩(ex01, ex02)
예제를 쓱 보니 ex02에 연산자 오버로딩을 집중적으로 하게 되므로, 한번에 정리.
과제에서 요구 :  대입 연산자(`=`), 산술연산자(`+`, `-`, `*`, `/`), 비교연산자(`>`, `<`, `>=`, `<=`, `==`, `!=`), 증감 연산자(`++Fix`, `--Fix`, `Fix++`, `Fix--`), stream 삽입 연산자 오버로딩(`<<`)

#### 연산자 오버로딩 선언 위치
연산자 오버로딩은 클래스 내에서 하거나, 클래스 밖에서 할 수 있다. 이때 <U>자기 자신을 리턴</U>하거나 <U>private영역의 멤버를 사용</U>해야 연산자들은 내부 연산자로 오버로딩 한다.
![overloading table](/images\42seoul\cpp\operator_overloading.png)
- `=`, `()`, `[]`, `->`는 연산자 오버로딩은 클래스 내부에서만 가능하다.
- 오버로딩된 연산자@는 a.operator@(b), operator@(a, b)형태 처럼 호출하여 사용할수 있다.

쭉 찾아본 결과 특정 몇개를 제외하고는 어디서 멤버로 선언 할지 말지는 크게 상관 없는것 같다. 하지만 객체지향적인 관점에서 볼때 전역은 지양하는게 좋다. 따라서 해당 과제에서는 큰 이유가 없으면 멤버로서 오버로딩한다.

#### 오버로딩 제한사항
- `::`(범위연산자), `.`(멤버 접근), `.*`(포인터를 통한 맴버 접근), `?`(삼항조건연산자)는 오버로딩 불가
- 기존에 없던 새로운 연산자는 생성 불가
- `->`를 오버로딩 할때는 raw포인터(?)나 ->가 차례로 오버로드 되는 객체가 반환되어야한다.
- `||`, `&&`를 오버로드 하는것은 이들의 short-circuit evaluation을 잃어버리게 된다.
    - short-circuit evaluation : `A && B`에서 `A`가 `False`면 `B`를 확인하지 않고 바로 넘어가는 기능.
    - C++17까지는 short-circuit evaluation를 잃는것에 `,`도 포함된다고 한다.

#### 대입 연산자 오버로(`=`, 컴파일러 자동 생성)
```cpp
Fix& operator=(Fix& other);
```
-> 얋은복사 깊은복사에 주의. 

복사 생성자(Fix(Fix& other))에 활용 가능하며, 복사생성자 또한 컴파일러가 없으면 자동생성한다.

#### 산술 연산자 오버로딩(`+`, `-`, `*`, `/`)
```cpp
Fix operator+(Fix& term);  // a + b → a.operator+(b)
Fix operator-(Fix& term);  // a - b → a.operator-(b)
Fix operator*(Fix& term);  // a * b → a.operator*(b)
Fix operator/(Fix& term);  // a / b → a.operator/(b)
```

#### 비교연산자 오버로딩(`>`, `<`, `>=`, `<=`, `==`, `!=`)
```cpp
bool operator>(Fix& term);  // a > b  → a.operator>(b)
bool operator<(Fix& term);  // a < b  → a.operator<(b)
bool operator>=(Fix& term); // a >= b → a.operator>=(b)
bool operator<=(Fix& term); // a <= b → a.operator<=(b)
bool operator==(Fix& term); // a == b → a.operator==(b)
bool operator!=(Fix& term); // a != b → a.operator!=(b)
```

#### 증감연산자 오버로딩(`++Fix`, `--Fix`, `Fix++`, `Fix--`)
증감연산자는 매개변수 int 여부에 따라 전위증감과 후위증감을 구분한다. 있으면 후위이며 단지 단수위 전위와 후위를 구분하는 용도이다. 

또한 전위의 경우 증감이 반영된 현재의 자신(`Fix&`)을 리턴하고, 후위는 반영되기 이전의 객체(`Fix`)를 미리 복사하고 리턴한다.
```cpp
Fix& operator++();      // ++fix
Fix& operator--();      // --fix
Fix operator++(int);    // fix++
Fix operator--(int);    // fix--
```

추가 : 보통의 후위 증감연산의 경우 후위연산보다 느리다. 증감 이전의 객체를 미리 복사해야하고 이를 포인터/참고가 아니라 그대로 반환하기 때문이다.

#### stream 삽입/추출 연산자 오버로딩(`<<`, `>>`)
전역으로 선언한다. 
```cpp


```

ref : [cppreference.com](https://en.cppreference.com/w/cpp/language/operators)