---
layout: post
title: "쉽게 배우는 OS Chapter04 CPU스케줄링"
description: "리마인드용 쉽게배우는 운영체제 핵심만"
date: 2022-02-10
tags: [OS]
comments: true
share: true
---

CPU 스케줄링과 스레드? 해당 파트에선 너무 프로세스 관점에서만 이야기하는거 같은데...

# CPU 스케줄링
## 4.1 스케줄링 개요
CPU 스케줄러는 여러 프로세스의 상황을 고려하여 CPU의 자원을 어떻게 배정할지 결정한다.
### 4.1.2 스케줄링의 단계
![스케줄](/images/level_of_scheduling.jpeg)
#### 4.1.2.1 고수준 스케줄링
(=장기스케줄링, 작업스케줄링) 시스템 내의 전체 작업 수를 조절하는 스케줄링(작업 : 운영체제에서 다루는 가장 큰 일의 단위. 1개 이상의 프로세스로 구성). 멀티프로그래밍 정도를 나타낸다.
#### 4.1.2.2 저수준 스케줄링
CPU가 어떤 프로세스를 실행하고, 언제 대기상태로 보낼지 정하는 스케줄링. 해당 챕터에서 다룰 스케줄링은 저수순 스케줄링이다.
#### 4.1.2.3 중간수준 스케줄링
고수준 스캐줄링을 통해 적절한 프로세스 개수를 조절했다고 하더라도, 실행 중간에 과부하가 발생할 수 있다. 중간수준 스케줄러는 이미 활성화된 프로세스 중 일부를 보류상태로 보내 시스템의 작업수를 조절한다.
### 4.1.3 스케줄링의 목적
- 공평성 : 모든 프로세스가 자원을 공정하게 배분받아야함
- 효율성 : 자원(CPU)가 유휴시간 없이 사용되야함
- 안정성 : 프로세스간 우선순위를 매겨 중요프로세스가 우선권을 가짐으로서 자원을 보호한다.
- 확장성 : 프로세스 증가 및 변경에도 안정적으로 동작하게 한다.
- 반응시간 보장 : 사용자에게 적절한 시간 내에 응답하여야한다.
- 무한 연기 방직 : 특정 프로세스의 작업이 무한이 연기되서는 안된다.

## 4.2 스케줄링시 고려사항
### 4.2.1 선점형 스케줄링과 비선점형 스케줄링
- 선점형 스케줄링 : 운영체개가 필요하다고 판단되면 실행상태의 프로세스를 빼앗을수 있는 스케줄링 방식 -> 응답시간이 빨라지나, 문맥교환같은 오버헤드가 생김. 시분할 방식 스케줄러에 사용.
- 비선점형 스케줄링 : 어떤 프로세스가 CPU를 점유하던, 중간에 끊을수 없는 스케줄링 방식 -> 오버헤드가 적어지나, 전체 시스템 처리률이 떨어짐. 일괄처리 방식 스케줄러에 사용.

선점형 스케줄러를 주로 사용하지만, 비선점 방식으로 작동해야하는 프로세스가 있을 수 있다(업데이트, 백업 등). 이런 프로세스의 경우 중요도를 매우 낮게 설정하여 선점형 프로세스에 영향을 덜 치미게 한다.

### 4.2.2 프로세스 우선순위
대부분은 프로세스마다 중요도를 매긴다. 우선순위가 높은 프로세스는 더 빨리, 자주 실행되어야하며, 이렇게 우선순위가 높은 프로세스들은 커널프로세스, 전면 프로세스, 대화형 프로세스, 입출력 집중 프로세스(동영상재생) 등이 있다.
- 커널 프로세스 <-> 사용자 프로세스
- 입출력 집중 프로세스(데이터 복사 등) <-> CPU집중 프로세스(수학연산)
- 전면 프로세스 <-> 후면 프로세스
- 대화형 프로세스 <-> 일괄처리 프로세스

## 4.3 다중 큐
### 4.3.1 준비상태 다중 큐
우선순위가 같은 PCB끼리 큐 형태로 관리가 된다.
이러한 우선순위에는 두가지 방식이 있다.
- 고정 우선순위 : 한번 프로세스에 우선순위가 정해지면 바뀌지 않는것. 구현이 쉽지만 시스템 변화에 대응이 힘듦
- 변동 수선순위 : 프로세스의 우선순위가 작업 중 변하는 방식. 구현은 어렵고 오버헤드가 조금 있지만, 시스템에 효율적으로 반응할 수 있다.
### 4.3.2 대기상태 다중 큐
대기상태의 PCB들은 같은 I/O끼리 큐 형태로 관리된다. 인터럽트 벡터를 통해 여러개의 입출력 인터럽트가 동시에 처리될수도 있다.

## 4.4 스케줄링 알고리즘

스케줄링 알고리즘은 특정 큐에 독자적으로 적용되는 동작방식이고, 큐를 나누는 기준은 우선순위.  
- 비선점형 알고리즘 : 비선점형 스케줄러가 사용하는 알고리즘. 작업이 끝날때 까지 한 프로세스가 CPU를 점유한다.
  - FCFS 스케줄링 : 준비큐에 도착한 순서대로 CPU에 할당하는 방식. 콘보이 효과때문에 효율이 떨어짐.
  - SJF 스케줄링 : 준비큐에 있는 프로세스 중 실행시간이 가장 짧은 순서대로 CPU에 할당. 프로세스별로 얼마나 걸리지 판단하기 힘들고, 공정성이 떨어지므로(오래걸리는 프로세스 아사) 사용 안함.
  - HRN 스케줄링 : 실행시간 뿐만이 아니라 CPU사용을 위해 기다린 시간까지 고려한느 방식. 아사현상을 완화하지만 여전히 공정성이 위배되어 사용 안함.
- 선점형 알고리즘 : 선점형 스케줄러가 사용하는 알고리즘
  - 라운드 로빈 스케줄링 : 실행상태의 프로세스는 CPU를 한 타임슬라이스동안 점유하고, 이후 대기 큐의 맨 뒤로 가서 차례를 기다리는 방식. 타임슬라이스가 짧을수록 문맥교환에의한 오베헤드가 커지므로 타임슬라이스를 적절하게 분배한다.
  - SRT 스케줄링 : 라운트 로빈 스케줄링에서, 대기중인 프로세스 중 작업시간이 짧은 프로세스가  먼저 CPU를 점유하는 스케줄링 방식. 남은 프로세스들의 시간을 계산해야하는 추가 오버헤드와 이 시간을 정확하게 알 수 없는 문제가 있어서 잘 사용하지 않는다.
- 종합선물세트(주로 선점형 + 우선순위)
  - 다단계 큐 스케줄링 : 각 큐마다 다른 스케줄링 가능, 우선순위에 따라 큐 구분.
  - 다단계 피드백 큐 스케줄링
### 4.4.8 다단계 큐 스케줄링
![MulitlevelQueue](/images/OS_MulitlevelQueue.png)

우선순위에 따라 준비큐를 여러개 사용하는 방식. 프로세스는 실행시 부여받은 우선순위에 따라 각 큐에 삽입되고, **우선순위는 변하지 않는다**. 각 큐는 주로 라운트 로빈방식으로 동작하며 타임슬라이스는 큐마다 다르게 적용 가능하다.

즉, 각 큐마다 프로세스 우선순위/작업형태를 고려하여 스케줄링 알고리즘을 적용 가능하다. 예를 들면 전면프로세스들의 준비큐는 응답성 향상을 위해 타임슬라이스를 작게 하고, 후면프로세스들의 준비큐는 상호작용이 없으므로 FCFS방식을 사용한다.

하지만 더 높은 우선순위의 큐의 프로세스들이 전부 끝나기(exit) 전까지는 낮은 우선순위 프로세스는 할당되지 못하는 문제가 있다.

### 4.4.9 다단계 피드백 큐 스케줄링
![MulitlevelFeedbackQueue](/images/OS_MulitlevelFeedbackQueue.png)
다단계 피드백 큐 스케줄링은 CPU를 사용 후 timeout된 프로세스는 한단계 낮은 우선순위의 큐 끝으로 이동한다. 또한 각 큐(우선순위)마다  타임슬라이스가 달라서, CPU를 얻기 힘든 프로세스일수록 점유 시간이 늘어난다. 이때 가장 낮은 우선순위 큐는 FCFS방식으로 동작한다. 오늘날 가장 일반적으로 사용하는 스케줄링 방식이며, 변동 우선순위 알고리즘의 전형적인 예이다.


## 심화학습
### 인터럽트와 이중모드
![dualmode](/images/OS_dualmode.png)
1. 사용자가 직접 시스템 호출 인터페이스를 사용하여 시스템 자원 사용(자발적). 사용이 어렵고 기능이 제한적이다.
2. 운영체제가 제공하는 API를 통해 시스템 자원 사용(자발적). API가 준비한 함수들을 이용해 시스템 자원에 접근 가능하다.
3. 인터럽트가 발생하면 커널 프로세스레 직접적으로 커널모드에 접근할수 있다. 하지만 인터럽트는 주로 발생하는 것이고, 발생시키더라도 핸들러를 통해 정해진대로 대응되므로 비자발적이다.
