---
layout: post
title: "전문가를 위한 cpp 몰랐던 거"
description: "/"전문가를 위한 cpp/"를 읽고 몰랐던 부분 간략하게 적는 포스트."
date: 2022-5-24
tags: [cpp]
comments: true
share: true
---

## 8장
### 8.3 객체의 라이프 사이클
#### 🌕 8.3.1 객체 생성 - 생성자 여러개 제공하기.
생성자에서 생성자를 호출할 때 호출 위치에 따라 동작 방식이 달라진다
```cpp
TestClass::TestClass(std::string name)
// ⬇️ 초기화 리스트에서 생성자 호출 = 위임생성자. 같은 인스턴스의 생성자 호출.
: TestClass::TestClass()
{
    TestClass::TestClass(); // 임시객체가 생성된다. 즉, 다른 인트턴스의 생성자가 호출된다.
}
```

#### 🌕 8.3.1 객체 생성 - 디폴트 생성자 작성 방법
디폴트 생성자 호출시, 스택 객체를 생성할 때와 힙 객체를 생성할 때 차이가 존재한다.
```cpp
//---------[STACK]----------
// 스택 객체에서 디폴트 생성자 호출시 ()를 쓰지 않는다.
TestClass tc(); // ❌. TestClass를 반환하는 tc()라는 함수로 인식.
tc.getName();   // 컴파일 에러 발생 지점. 함수를 객체처럼 사용하는 걸로 판단.

//---------[HEAP]----------
// 힙 객체에서는 클래스()형태로도 디폴트 생성자를 호출 가능하다.
auto smartPtr = make_unique<TestClass>();   // ⭕️
TestClass* tc1 = new TestClasss();          // ⭕️
TestClass* tc1 = new TestClasss;            // ⭕️
```
#### 🌕 8.3.1 객체 생성 - 생성자 이니셜라이저.
생성자 {} 내부에서 작성되는 코드는 이미 클래스가 인스턴스화 된 이후이다. 즉 멤버가 초기화 된 이후 동작하는 코드이다. 생성자 이니셜라이저에 있는 코드는 인스턴스를 생성하는 과정에서 동작하는 코드이므로, 멤버의 초기값등을 정할수 있는 코드이다. 당연히 <u>처음부터 초기값으로 만드는게 초기화 시키고, 그 값을 대입하는것 보다 더 효율적이다</u>(성향차 이긴 하다).

이때 생성자 이니셜라이저로 초기화하거나 생성자를 호출해야하는 멤버들이 있다.
- const 멤버 변수
- 참조 멤버 변수
- 디폴트 생성자가 없는, 객체 맴버 변수(클래스 내부에 선언된 또 다른 클래스)
- 디폴트 생성자가 없는, 베이크 클래스

생성자 이니셜라이저의 순서는 클래스 정의에 선언된 순서대로 멤버를 초기화한다.
```cpp
class Testclass
{
    private:
        int val1;
        int val2;
}
```
```cpp
// ⭕️. val1에 1이 대입되고, val2에 val1값이 대입됨.
Testclass::Testclass()
: val1(1), val2(val1) {}

// ❌. 클래스에 정의된 순서인 val1→val2로 초기화됨. val1에는 쓰레기값이 들어간다.
Testclass::Testclass()
: val2(1), val1(val2) {}
```

#### 🌕 8.3.1 객체 생성 - 컴파일러가 생성하는 생성자 정리.
컴파일러가 생성사 중 디폴트생성자와 복사생성자는 자동으로 생성한다. 이때 자동으로 생성하는 방식은 각각 다음과 같다.

- 디폴트 생성자
    - 어떠한 생성자도 정의 안됨 → 디폴트 생성자 생성
    - 어떠한 생성자라도 정의됨 → 디폴트 생성자 안 만듦
- 복사 생성자
    - 복사 생성자가 정의 안됨 → 디폴트 복사생성자 생성
    - 복사 생성자가 정의되어 있음 → 디폴트 복사생성자 안 만듦

두개다 섞어서 경우의 수를 생각하면 경우의수가 많아지고 복잡하다. 각각 생각하면 심플함.

#### 🌖 8.3.3 객체에 대입하기
c++에서 복제(copy)는 객체를 초기화 할 때 적용되는 표현이다. 이미 할당된 객체(인스턴스)에 덮어쓸 때는 대입(assign)이라고 표현한다.

#### 🌖 8.3.3 객체에 대입하기 - 대입연산자 정의방법
대입연산자(=)는 복제 생성자와 다음과 같은 차이가 있다.
- 대입연산자와 달리 복제 생성자는 인스턴스 생성시 딱 한번만 호출된다.
- 대입연산자에는 자기 자신을 대입할 수 있다.

따라서 대입연산자를 구현(오버로딩)할때는 자기 자신을 대입하는 경우도 반드시 고려해야한다.

예를 들면 클래스 내에 동적으로 할당한 메모리가 있거나, 다른 리소스들이 있다면 자기 자신을 대입하는 작업에서 문제가 발생할 가능성이 크다. 따라서 아래처럼 대입연산자 시작시 확인해보는게 가장 좋다.
```cpp
// rhs : Right Hand Side
TestClass& TestClass::operator=(const TestClass& rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ...
    return *this;
}
```

#### 🌖 8.3.4 컴파일러가 만들어주는 복제 생성자 복제/대입 연산자.
C++ 11부터 다음과 같은 기능들을 지원하지 않는다.
- 사용자가 선언한 복제/대입연산자(=), 소멸자(~)가 있으면 → 디폴트 복제 생성자 생성을 지원하지 않는다.
- 사용자가 선언한 복제생성자, 소멸자(~)가 있으면 → 디폴트 복제/대입 연산자(=) 생성을 지원하지 않는다.

#### 🌖 8.3.5 복제와 대입 구분하기.
기본적으로 선언에서는 복제 생성자를 사용한다. 또한 이미 생성된 객체에 대입하는 대입문에서는 복제/대입 연산자를 사용한다. 따라서 아래의 선언문들은 복제 생성자를 사용한다.
```cpp
Testclass tc1(10);
Testclass tc2(tc1);
Testclass tc3 = tc1;
```

#### 🌖 8.3.5 복제와 대입 구분하기 - 리턴값이 객체인 경우.
참고 : 리턴된 임시 객체는 명령 라인()이 끝날때 사라진다. 

임시객체에 대입연산을 줄여서 오버헤드를 줄이는 리턴값 최적화를 컴파일 단계에서 적용하기도 하고, 이동생성자/연산자를 호출하여 임심객체에 대한 오버헤드를 줄인다.